
대본에 필요한 내용 정리.
html, css부분은 특별한 것을 사용하지 않았으므로 설명하지 않았고
프로젝트에서 새로 쓰게 된 개념만 설명함.


<<<<<<<login.jsp>>>>>>>>>

html 
<form>태그: 사용자 입력을 받는 데 사용.
method 속성으로 어떤 http 요청 방법을 사용할지 지정 가능.
get or post
get: 주로 데이터를 가져오기 위해 사용. get 요청은 캐시될 수 있으므로 같은 요청 반복시 데이터를 다시 받지 않을 수 있음
post: 데이터를 전송하는데 사용. post 요청은 캐시되지 않으므로 서버로부터 항상 새로운 데이터를 받음. 로그인같은 보안이 필요한 데이터 전송에 적합.
get 장점: 빠르고 간단, url에 데이터가 포함되어 전송되므로, 즐겨찾기나 링크로 데이터 공유시 용이, 캐싱이 가능하므로 같은 요청이 반복될 경우 서버로부터 데이터를 다시 받지 않음
get 단점: url에 데이터가 포함되어 전송되므로 보안에 취약->사용자가 입력한 개인정보나 민감한 정보 노출 가능, 전송할 수 있는 데이터 크기 제한적, 사용자가 url을 통해 데이터 수정 가능
post 장점: url에 데이터가 노출되지 않으므로 보안상 안전, 전송할 수 있는 데이터 크기 제한 없음, 데이터 수정 및 삭제 등 다양한 작업 지원
post 단점: get 방식에 비해 더 복잡, 캐싱이 불가능하므로 매번 새로운 요청 생성, url에 데이터가 노출되지 않기 때문에 즐겨찾기나 링크로 데이터 공유 어려움
결론: get방식은 데이터가 크지 않고 보안이 중요하지 않은 경우에 유용,
post방식은 데이터가 많거나 보안이 중요한 경우에 유용.

get 방식에서 데이터 제한이 있다?? -> 브라우저와 서버에서 설정한 값에 따라 다름. 대부분 브라우저는 url 최대 길이를 2048자로 제한.

캐시(cache): 데이터나 리소스를 미리 저장해두는 임시 저장소. 캐시를 사용하면 다시 사용될 가능성이 높은 데이터를 빠르게 불러올 수 있어서 성능 향상 가능.
웹에서의 캐시: 브라우저 캐시, 프록시 캐시, CDN 캐시.
우리는 브라우저 캐시를 사용. 브라우저 캐시: 동일한 요청이 반복될 때 서버에서 데이터를 다시 받지 않고 브라우저의 캐시에서 데이터를 불러오는 기능.
post방식에서 캐싱이 불가능 한 이유? post요청은 서버에 새로운 데이터를 전송하기 때문에 같은 요청이 반복될 때마다 서버는 항상 새로운 데이터를 받아야 하기 때문.


-->>이번 프로젝트에서 form 태그의 get, post 방식을 사용해 데이터를 보내서 그 데이터로 테이블에서 값을 읽어오는데 사용.
로그인, 검색창에서 사용.
또한 form 에서 action속성을 사용.
form 태그 내부에 입력한 데이터를 전송할 때 이 데이터를 처리할 서버 측 스크립트 파일을 지정하는 속성.
입력 데이터를 받은 것을 어떻게 처리할지 정함(?)
예를들어 로그인 페이지에서 아이디와 비밀번호를 입력받으면 그것을 어떻게 처리하는지...
중요한 것: form 태그 내부에 input이나 button에서 submit 버튼이 있어야 함. submit을 눌러야 입력한 데이터가 action속성에 지정된 url로 전송됨.

login 밑에 가입하기는 a태그 링크를 주지 않고 onclick 이벤트로 해봤음..



<<<<<<<join.jsp>>>>>>>>>>>
join창에서도 앞과 마찬가지로 form 태그를 이용해 입력값을 받아 처리하는 형식으로 함.
join은 개인정보이기 때문에 form태그의 method 속성을 post로 함.
회원가입 버튼을 눌렀을때 onclick 이벤트가 먼저 발생이 됨. onclick="return joinCheck()" 으로 joinCheck 메서드를 사용함.
<<<<<joincheck.js>>>>>>
joincheck.js에서는 메서드를 만들어 입력된 값들의 유효성 검사를 함.
html 수업시간에 배웠던 정규식을 사용해 각각의 항목에 들어갈 수 있는 값들의 제한을 줌.
예를 들어서 이름 항목에는 한글으로만 구성되도록..
또한 입력하지 않은 값이 있다면 alert창으로 경고를 주고 focus가 가도록 함.
if-else if문으로 모든 검사가 끝나면 true값을 반환해 join.jsp에서 insertmember.jsp 페이지로 넘어감

<<<<<insertmember.jsp>>>>>>>
회원가입 창에서 입력받은 값을 oracle db에 저장하는 기능 구현.
6번째줄의 <%@page import="java.sql.*" %>으로 java.sql 패키지를 불러옴. 이 패키지에는 jdbc api에 필요한 인터페이스와 클래스가 포함되어 있음. 이를 통해 java 언어로 db에 연결하고, 쿼리를 실행하고 결과를 처리 가능.
19~24번째 줄에서 입력받은 값들을 각각 변수에 저장하고 데이터 베이스와 연결함.
sql이라는 변수에 쿼리문을 넣어 실행시키도록 함.
먼저 db와 연결하기 위해 35~36번째 줄의 코드를 실행시킴. 
DriverManager.getConnection()함수는 jdbc api에서 데이터베이스 연결을 생성하는 메서드. 데이터베이스url, 사용자이름, 암호를 매개변수로 받아 해당 db에 대한 연결(connection)객체를 반환함.
PreparedStatement는 미리 컴파일 된 sql문을 나타냄. 이것을 사용하면 반복적으로 실행되는 sql문의 성능 향상 가능. 
PreparedStatement객체는 connection 객체의 PreparedStatement() 메서드를 호출하여 생성됨. 이 객체를 이용해 쿼리 실행.
쿼리문에서 insert into member(custid, custpw, custname, custphone, custadd) values(?, ?, ?, ?, ?) 이 부분의 ? 부분에 입력받은 값을 넣게 됨.
try문에서 예외가 발생하면  46~47번째 줄의 코드로 예외처리 함.
e.printStackTrace(); 이 함수는 예외 발생 시 해당 예외에 대한 정보를 출력하는 메서드.
입력을 했다면 50~56번째 줄에서 connection객체와 preparedstatement 객체를 닫음. 닫지 않으면 db에 대한 연결이 계속 유지되므로 메모리 낭비가 발생 가능.->메모리를 효율적으로 관리
db에 데이터를 저장하면 다시 login창으로 돌아가 로그인을 하게 함.
login을 하게 되면 main페이지로 넘어가게 됨. 


<<<<<<logincheck.jsp>>>>>>>>
회원가입 창과 마찬가지로 db와 연결해 db에 저장된 아이디,비밀번호가 맞는지 확인을 함.
쿼리문은 SELECT COUNT(*) AS cnt FROM member WHERE custid = ? AND custpw = ? 문을 사용.
id와 pw가 맞으면 if문의 cnt가 1이므로(if에서는 cnt>0으로 줌) 세션에 로그인 정보를 저장함.
else는 0이므로 로그인에 실패하고 경고창이 뜨며 다시 login창으로 돌아가게 함.
세션에 loginUser라는 이름으로 custid를 속성값으로 저장하게 됨.
세션은 서버와 클라이언트간의 상태 정보를 유지하기 위해 사용, 클라이언트와 연결이 지속되는 동안 클라이언트의 요청이 서버에 전송될 때마다 세션을 식별하여 해당 세션에 대한 정보를 유지.
자바에서는 HttpSession 객체를 생성해 세션 속성에 값을 저장하거나 가져올 수 있음.


<<<<<main.jsp>>>>>>>
logincheck.jsp에서 생성한 세션으로 main페이지에서 로그인을 했는지 확인하고 로그인을 하지 않았으면 접근하지 못하게 함.
7~16 줄의 자바코드로... 세션이 null이 아니고 loginUser가 null이 아니면 loginUser의 값을 가져옴. null이라면 81~85번째 줄에서 login.jsp로 가도록 만듬.
위에서 설명한 대로 form 태그를 사용해 입력값을 받고 저장된 데이터를 보여주는 방식을 사용함.
검색창은 header에도 있는데 그것도 마찬가지로 똑같은 기능임.
검색을 한다면 search.jsp로 이동하게 됨.

<<<<<header-logout.jsp>>>>>
로그아웃을 누르면 세션을 모두 삭제시키고 로그인 페이지로 이동시키게 함.
session.invalidate(); 함수는 현재 사용자의 세션을 무효화 시키는 역할을 하는 코드.
세션이 무효화되면 세션 객체는 삭제되며, 세션에 저장된 모든 속성들도 함께 삭제


<<<<search.jsp>>>
위에서 사용한 기능 그대로 사용. 입력받은 값은 query라는 이름으로 저장되어 사용.
쿼리문은 select문 사용 (57번째 줄) or을 사용해 데이터 값이 어느 속성에 있어도 가져올 수 있도록 함.
60번째의 for문은 입력받은 값을 "query"의 형식으로 쿼리문에 넣기 위해 사용.
67번째의 while문으로 검색된 입력값들의 데이터를 끝까지 보여주기 위해 사용.


<<<각각의 세부 종류 페이지>>>>
search.jsp로 넘어가게 함
아 search도 주제에 맞게 57번째줄 테이블명 바꿔서 각각 만들어야 할 듯

<<<search_trek.jsp>>>>
세 개의 테이블을 사용했음. 그런데 검색할 때 세 개의 테이블에서 값을 다 가져오고 싶었는데 그냥 쿼리문을 쓰면 각각의 테이블에서 각 속성을 다 가져와야해서
쿼리문이 엄청나게 길어짐 그래서 view 사용함.
뷰 trek을 생성해서 각 테이블을 union all로 합집합으로 결합함.



